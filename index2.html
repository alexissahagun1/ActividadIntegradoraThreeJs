<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import Stats from "https://unpkg.com/three/examples/jsm/libs/stats.module.js";
        import {OrbitControls} from "https://unpkg.com/three@0.119.0/examples/jsm/controls/OrbitControls.js";
        import {OBJLoader} from 'https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/loaders/OBJLoader.js';

        "use strict";

        let renderer, scene, camera, orbitControls, stats, gui, data, dataReady = false, frame = 0, ambientLight, directionalLight, pointLight, model;
        let street, streetLines;
        
        function init(event) {
            // RENDERER ENGINE
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setClearColor(new THREE.Color(0, 0, 0));
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // SCENE
            scene = new THREE.Scene();

            // MODELS
            const scenary = new Scenary();
            const street = new Street(2600, 1000, 130, 1200);
            const streetLines = new StreetLines();

            // LIGHTS
            ambientLight = new AmbientLight();
            directionalLight = new DirectionalLight();
            pointLight = new PointLight();

            camera = new Camera();
            camera.setPerspectiveView();


            // SCENE GRAPH
            scene.add(scenary);
            scene.add(street);
            scene.add(streetLines);
            
            scene.add(ambientLight);
            scene.add(directionalLight);
            scene.add(pointLight);


            // CAMERA (PERSPECTIVE)
            // const fov = 60;    // Field ov view
            // const aspect = window.innerWidth / window.innerHeight;
            // const near = 0.01;
            // const far = 10000.0;
            // camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            // camera.position.set(-100, 100, 300);
            // // CAMERA CONTROLS
            // orbitControls = new OrbitControls(camera, renderer.domElement);
            // //orbitControls.target = model.position;
            // orbitControls.update();

            // SETUP STATS
            stats = new Stats();
            stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
            document.body.appendChild(stats.dom);

            // GUI
            gui = new dat.GUI();




            // SCENE-MENU
            const guiSceneMenu = gui.addFolder("Scene Menu");
            guiSceneMenu.add(scenary.axes, "visible").setValue(scenary.axes.visible).name("World Axes").listen().onChange(function(value) {
                scenary.axes.setVisible(value);
            });
            guiSceneMenu.open();

            const guiCameraView = gui.addFolder("Camera View");

            guiCameraView.add(camera.orbitControls, "autoRotate").setValue(camera.orbitControls.autoRotate).name("Rotate").listen().onChange(function(value) {
            });
            guiCameraView.add(camera, "perspectiveView").name("Perspective Camera").listen().onChange(function() {
                camera.setPerspectiveView();

            });
            guiCameraView.add(camera, "topView").name("Top Camera").listen().onChange(function() {
                camera.setTopView();
            });
            guiCameraView.add(camera, "frontView").name("Front Camera").listen().onChange(function() {
                camera.setFrontView();
            });
            guiCameraView.add(camera, "sideView").name("Side Camera").listen().onChange(function() {
                camera.setSideView();
            });
            guiCameraView.add(camera, "modelView").name("Inside Camera").listen().onChange(function() {
                camera.setInModelView();
            });

            guiCameraView.open();

            const guiAmbientLight = gui.addFolder("Ambient Light");
            

            guiAmbientLight.add(ambientLight, "visible").name("On").setValue(ambientLight.visible).listen().onChange(function(value) {

            });
            guiAmbientLight.addColor(ambientLight, "strColor").name("Color").setValue(ambientLight.strColor).listen().onChange(function(value) {
                ambientLight.setColor(value);
            });
            guiAmbientLight.add(ambientLight, "intensity").name("Intensity").min(0).max(1).step(0.1).setValue(ambientLight.intensity).listen().onChange(function(value) {

            });

            const guiDirectionalLight = gui.addFolder("Directional Light");
            guiDirectionalLight.add(directionalLight, "visible").name("On").setValue(directionalLight.visible).listen().onChange(function(value){

            });

            guiDirectionalLight.add(directionalLight.position, "x").name("x").min(-10).max(10).step(0.1).setValue(0).listen().onChange(function(value) {

            });
            guiDirectionalLight.addColor(directionalLight, "strColor").name("Color").setValue(directionalLight.strColor).listen().onChange(function(value) {
                directionalLight.setColor(value);
            });
            guiDirectionalLight.add(directionalLight, "intensity").name("Intensity").min(0).max(1).step(0.1).setValue(directionalLight.intensity).listen().onChange(function(value) {

            });
            guiDirectionalLight.open();

            const guiPointLight = gui.addFolder("Point Light");

            guiPointLight.add(pointLight, "visible").name("On").setValue(pointLight.visible).listen().onChange(function(value){

            });

            guiPointLight.add(pointLight.position, "y").name("y").min(0).max(3).step(0.1).setValue(pointLight.position.y).listen().onChange(function(value) {

            });
            guiPointLight.addColor(pointLight, "strColor").name("Color").setValue(pointLight.strColor).listen().onChange(function(value) {
                pointLight.setColor(value);
            });
            guiPointLight.add(pointLight, "intensity").name("Intensity").min(0).max(1).step(0.1).setValue(pointLight.intensity).listen().onChange(function(value) {

            });

            guiPointLight.open();


            // READ JSON DATA
            readTextFile('./simul_data2.json', function(text){
                data = JSON.parse(text);
                for(let i = 0; i < data.cars.length; i++){
                    const id =  data.cars[i].id;
                    const x =  data.cars[i].x;
                    const z =  data.cars[i].z;
                    const dir = data.cars[i].dir;
                    const type = data.cars[i].type;

                    var car = createCar(type);
                    car.position.set(x, 0, z);
                    car.rotation.y = dir * Math.PI / 180;
                    car.name = id;
                    scene.add(car);
                }
                for(let i = 0; i < data.semaphores.length; i++){
                    const id =  data.semaphores[i].id;
                    const x =  data.semaphores[i].x;
                    const z =  data.semaphores[i].z;
                    const dir = data.semaphores[i].dir;
                    const state = data.semaphores[i].state;

                    var semaphore = new Cube(x, z, dir, state, 20);
                    semaphore.name = id;
                    scene.add(semaphore);
                }
                dataReady = true;
            });

            // DRAW SCENE IN A RENDER LOOP (ANIMATION)
            renderLoop();
        }

        function renderLoop() {
            stats.begin();
            setTimeout( function() {
            requestAnimationFrame( renderLoop);
            }, 1000 / 30 );
            renderer.render(scene, camera);
            updateScene();
            stats.end();
        }

        function updateScene() {
           if(dataReady){
               if( frame < data.frames.length ){
                    // console.log('Frame: ', frame);
                    for(let i = 0; i < data.frames[frame].cars.length; i++){
                        
                        const id =  data.frames[frame].cars[i].id;
                        const x =  data.frames[frame].cars[i].x;
                        const z =  data.frames[frame].cars[i].z;
                        const dir =  data.frames[frame].cars[i].dir - 90;
                        var car = scene.getObjectByName(id);

                        // car.setPosition(x, z);
                        // car.setDirection(dir);
                        if(!car){
                            var car = createCar();
                            car.position.set(x, 0, z);
                            car.rotation.y = dir * Math.PI / 180;
                            car.name = id;
                            scene.add(car);
                        } else{
                            car.position.set(x, 0, z);
                            car.rotation.y = dir * Math.PI / 180;
                        }
                    }
                    for(let i = 0; i < data.frames[frame].semaphores.length; i++){
                        
                        const id =  data.frames[frame].semaphores[i].id;
                        const state = data.frames[frame].semaphores[i].state;
                        var semaphore = scene.getObjectByName(id);

                        if(!semaphore){
                            var semaphore = new Cube();
                            semaphore.name = id;
                            scene.add(semaphore);
                        } else{
                            semaphore.setState(state);
                        }
                    }
                    frame++;
               }
           }
        }

        function readTextFile(file, callback) {
            var rawFile = new XMLHttpRequest();
            rawFile.overrideMimeType("application/json");
            rawFile.open("GET", file, true);
            rawFile.onreadystatechange = function() {
                if (rawFile.readyState === 4 && rawFile.status == "200") {
                    callback(rawFile.responseText);
                }
            }
            rawFile.send(null);
        }

        // EVENT LISTENERS & HANDLERS
        document.addEventListener("DOMContentLoaded", init);

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);            
        }, false);

        class Axes extends THREE.AxesHelper {
            constructor(size = 10, visible = false) {
                super(size);
                this.size = size;
                this.visible = visible;
                this.position.set(0, 1, 0);
            }
            setVisible(value) {
                this.visible = value;
            }
        }

        class Camera extends THREE.PerspectiveCamera {
            constructor(fov = 120, aspect = window.innerWidth / window.innerHeight, near = 0.01, far = 10000) {
                super(fov,aspect,near,far);
                this.perspectiveView = false;
                this.topView = false;
                this.frontView = false;
                this.sideView = false;
                this.modelView = false;

                //Camera Controls

                this.orbitControls = new OrbitControls(this, renderer.domElement);
                this.orbitControls.update();
            }

            setPerspectiveView() {
                this.position.set(-6, 6, -4.9);
                this.orbitControls.target = new THREE.Vector3(0,0,0);
                this.up.set(0,1,0);
                this.orbitControls.update();
                this.topView = false;
                this.frontView = false;
                this.sideView = false;
                this.modelView = false;
            }

            setTopView() {
                this.position.set(0, 1500, 0);
                this.orbitControls.target = new THREE.Vector3(0,0,0);
                this.up.set(0,1,0);
                this.orbitControls.update();
                this.perspectiveView = false;
                this.frontView = false;
                this.sideView = false;
                this.modelView = false;
            }

            setFrontView() {
                this.position.set(0, 10, -10);
                this.orbitControls.target = new THREE.Vector3(0,0,0);
                this.up.set(0,1,0);
                this.orbitControls.update();
                this.perspectiveView = false;
                // this.frontView = false;
                this.topView = false;
                this.sideView = false;
                this.modelView = false;
            }

            setSideView() {
                this.position.set(-9, 8, 0);
                this.orbitControls.target = new THREE.Vector3(0,0,0);
                this.up.set(0,3,0);
                this.orbitControls.update();
                this.perspectiveView = false;
                this.frontView = false;
                this.modelView = false;
            }


            setInModelView() {
                this.position.set(model.position.x, model.position.y + 0.3, model.position.z + 0.4);
                this.orbitControls.target = new THREE.Vector3(0,0,0);
                this.up.set(0,1,0);
                this.orbitControls.update();
                this.perspectiveView = false;
                this.topView = false;
                this.frontView = false;
                this.sideView = false;
                // this.modelView = false;
            }

            setAutoRotate(value = true) {
                this.orbitControls.autoRotate = value;
       
                
            }
        }

        class AmbientLight extends THREE.AmbientLight {
            constructor(color = 0xFFFFFF, intensity = 1) {
                super(color, intensity);
                this.strColor = color;
            }

            setColor(strColor) {
                this.color.setHex(strColor);
            }
        }

        class DirectionalLight extends THREE.DirectionalLight {
            constructor(color = 0xFFFFFF, intensity = 1) {
                super(color, intensity);
                this.strColor = color;
                this.position.set(0,10,0);
            }
            setColor(strColor) {
                this.color.setHex(strColor);
            }
        }

        class PointLight extends THREE.PointLight {
            constructor(color = 0xFFFFFF, intensity = 1) {
                super(color, intensity);
                this.strColor = color;
                this.position.set(0,3,0);
            }
            setColor(strColor) {
                this.color.setHex(strColor);
            }
        }



        class Floor extends THREE.Group {
            constructor(size = 100) {
                super();
                this.size = size;
                this.visible = false;
                const geometry = new THREE.PlaneGeometry(size, size);
                const material = new THREE.MeshBasicMaterial({color: 0x808080});
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2;
                this.gridHelper = new THREE.GridHelper(size, 10, 0xff0000, 0x000000);
                // CHILDREN
                this.add(this.mesh);
                this.add(this.gridHelper);
            }
            setVisible(value = true) {
                this.visible = value;
            }
            setWireframe(value = true) {
                this.material.wireframe = value;
            }
            setColor(color) {
                this.mesh.material.color.setHex(color);
            }
        }

        class Street extends THREE.Group {
            constructor(xSize = 100, ySize = 100, x = 0, z = 0) {
                super();
                const geometry = new THREE.PlaneGeometry(xSize, ySize);
                const material = new THREE.MeshBasicMaterial({color: 0x808080});
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2;
                this.mesh.rotation.z = -Math.PI / 2;
                // CHILDREN
                this.add(this.mesh);
                this.position.set(x, 0, z);
            }
            setVisible(value = true) {
                this.visible = value;
            }
            setWireframe(value = true) {
                this.material.wireframe = value;
            }
            setColor(color) {
                this.mesh.material.color.setHex(color);
            }
        }

        function createCar(value = 0) {
            var colors = [0xa52523, 0xffffff, 0x00008B, 0x000000, 0x0080000, 0x808080, 0xffa500];

            const car = new THREE.Group();

            const backWheel = createWheels();
            backWheel.position.y = 6;
            backWheel.position.x = -18;
            car.add(backWheel);

            const frontWheel = createWheels();
            frontWheel.position.y = 6;
            frontWheel.position.x = 18;
            car.add(frontWheel);

            const main = new THREE.Mesh(
                new THREE.BoxBufferGeometry(60, 15, 30),
                new THREE.MeshLambertMaterial({ color: colors[value] })
            );
            main.position.y = 12;
            car.add(main);

            const carFrontTexture = getCarFrontTexture();

            const carBackTexture = getCarFrontTexture();

            const carRightSideTexture = getCarSideTexture();

            const carLeftSideTexture = getCarSideTexture();
            carLeftSideTexture.center = new THREE.Vector2(0.5, 0.5);
            carLeftSideTexture.rotation = Math.PI;
            carLeftSideTexture.flipY = false;

            const cabin = new THREE.Mesh(new THREE.BoxBufferGeometry(33, 12, 24), [
                new THREE.MeshLambertMaterial({ map: carFrontTexture }),
                new THREE.MeshLambertMaterial({ map: carBackTexture }),
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // top
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // bottom
                new THREE.MeshLambertMaterial({ map: carRightSideTexture }),
                new THREE.MeshLambertMaterial({ map: carLeftSideTexture }),
            ]);
            cabin.position.x = -6;
            cabin.position.y = 25.5;
            car.add(cabin);

            return car;
        }

        function createWheels() {
            const geometry = new THREE.BoxBufferGeometry(12, 12, 33);
            const material = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const wheel = new THREE.Mesh(geometry, material);
            return wheel;
        }

        function getCarFrontTexture() {
            const canvas = document.createElement("canvas");
            canvas.width = 64;
            canvas.height = 32;
            const context = canvas.getContext("2d");

            context.fillStyle = "#ffffff";
            context.fillRect(0, 0, 64, 32);

            context.fillStyle = "#666666";
            context.fillRect(8, 8, 48, 24);

            return new THREE.CanvasTexture(canvas);
        }

        function getCarSideTexture() {
            const canvas = document.createElement("canvas");
            canvas.width = 128;
            canvas.height = 32;
            const context = canvas.getContext("2d");

            context.fillStyle = "#ffffff";
            context.fillRect(0, 0, 128, 32);

            context.fillStyle = "#666666";
            context.fillRect(10, 8, 38, 24);
            context.fillRect(58, 8, 60, 24);

            return new THREE.CanvasTexture(canvas);
        }

        class Cube extends THREE.Mesh{
            constructor(x = 0, z = 0, rotation = 0, state = 0, size = 1, color = 0xcc0000){
                super(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({color}));
                this.x = x;
                this.z = z;
                this.position.set(x, 50, z);
            }
            setState(value){
                if (value == 0){
                    this.material.color.setHex('0x00ff00');
                }
                if (value == 1){
                    this.material.color.setHex('0xffff00');
                }
                if (value == 2){
                    this.material.color.setHex('0xcc0000');
                }
            }
        }

        class Building extends THREE.Group {
            constructor(x = 0, z = 0, front = 50, depth = 50, height = 10, color = 0xcc0000, wireColor = 0xffffff) {
                super();
                this.front = front;
                this.length = length;
                this.height = height;
                this.position.set(x, 0, z);
                this.color = color;
                this.wireColor = wireColor;
                this.doubleSide = false;
                this.rotate = false;
                const geometry = new THREE.BoxGeometry(front, height, depth);
                const material = new THREE.MeshBasicMaterial({color});
                const materialWire = new THREE.MeshBasicMaterial({wireframe: true, color: wireColor});
                this.solid = new THREE.Mesh(geometry, material);
                this.wire = new THREE.Mesh(geometry, materialWire);
                // CHILDREN
                this.add(this.solid);
                this.add(this.wire);
            }
            setWireframe(value = true) {
                this.solid.setVisible(value);
            }
            setColor(hexColor) {
                this.color = hexColor;
                this.solid.material.color.setHex(hexColor);
            }
            setWireColor(hexColor) {
                this.wireColor = hexColor;
                this.wire.material.color.setHex(hexColor);
            }
            setDoubleSide(value) {
                this.doubleSide = value;
                if(value) {
                    this.solid.material.side = THREE.DoubleSide;
                } else {
                    this.solid.material.side = THREE.FrontSide;
                }
            }
            setOnFloor() {
                this.solid.geometry.computeBoundingBox();
                const bBox = this.solid.geometry.boundingBox;
                this.position.y = -bBox.min.y;
            }
        }

        class Line extends THREE.Mesh {
            constructor(xSize = 100, ySize = 100, x, z, rotation = 0) {
                super();
                const geometry = new THREE.PlaneGeometry(xSize, ySize);
                const material = new THREE.MeshBasicMaterial({color: 0xffff00});
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2;
                this.mesh.rotation.z = rotation * Math.PI / 180;
                // CHILDREN
                this.add(this.mesh);
                this.position.set(x, 1, z);
            }
        }

        class StreetLines extends THREE.Group {
            constructor() {
                super();
                this.lines = [];

                this.lines.push(new Line(2600, 20, 145, 1200, 90));

                for(let i = 0; i < this.lines.length; i++) {
                    this.add(this.lines[i]);
                }
            }
        }

        class Scenary extends THREE.Group {
            constructor(size = 1000) {
                super();
                this.axes = new Axes(size);
                this.floor = new Floor(size);
                // this.buildings = [];
                // //SE
                // this.buildings.push(new Building(35, 35, 50, 50, 50));
                // this.buildings.push(new Building(35, 90, 50, 50, 10));
                // this.buildings.push(new Building(35, 145, 50, 50, 20));
                // this.buildings.push(new Building(35, 200, 50, 50, 80));
                // this.buildings.push(new Building(35, 255, 50, 50, 40));
                
                // this.buildings.push(new Building(90, 35, 50, 50, 10));
                // this.buildings.push(new Building(145, 35, 50, 50, 30));
                // this.buildings.push(new Building(200, 35, 50, 50, 50));
                // this.buildings.push(new Building(255, 35, 50, 50, 10));
                // this.buildings.push(new Building(305, 35, 50, 50, 40));

                // // SW (Tec)
                // this.buildings.push(new Building(-35, 35, 50, 50, 5));
                // this.buildings.push(new Building(-35, 90, 50, 50, 5));
                // this.buildings.push(new Building(-35, 145, 50, 50, 5));
                // this.buildings.push(new Building(-35, 200, 50, 50, 5));

                // this.buildings.push(new Building(-35, 35, 50, 50, 10));
                // this.buildings.push(new Building(-90, 35, 50, 50, 20));
                // this.buildings.push(new Building(-145, 35, 50, 50, 20));
                // this.buildings.push(new Building(-205, 35, 50, 50, 20));
                // this.buildings.push(new Building(-260, 35, 50, 50, 20));
                
                // // NE
                // this.buildings.push(new Building(35, -35, 50, 50, 10));
                // this.buildings.push(new Building(90, -35, 50, 50, 20));
                // this.buildings.push(new Building(145, -35, 50, 50, 20));
                // this.buildings.push(new Building(205, -35, 50, 50, 20));
                // this.buildings.push(new Building(260, -35, 50, 50, 20));

                // this.buildings.push(new Building(35, -90, 50, 50, 10));
                // this.buildings.push(new Building(35, -145, 50, 50, 20));
                // this.buildings.push(new Building(35, -200, 50, 50, 20));
                // this.buildings.push(new Building(35, -255, 50, 50, 20));
                // this.buildings.push(new Building(35, -310, 50, 50, 20));
                
                // // NW
                // this.buildings.push(new Building(-35, -35, 50, 50, 10));
                // this.buildings.push(new Building(-90, -35, 50, 50, 20));
                // this.buildings.push(new Building(-145, -35, 50, 50, 20));
                // this.buildings.push(new Building(-205, -35, 50, 50, 20));
                // this.buildings.push(new Building(-260, -35, 50, 50, 20));

                // this.buildings.push(new Building(-35, -90, 50, 50, 10));
                // this.buildings.push(new Building(-35, -145, 50, 50, 20));
                // this.buildings.push(new Building(-35, -200, 50, 50, 20));
                // this.buildings.push(new Building(-35, -255, 50, 50, 20));
                // this.buildings.push(new Building(-35, -310, 50, 50, 20));

                // CHILDREN
                this.add(this.axes);
                this.add(this.floor);
                // for(let i = 0; i < this.buildings.length; i++) {
                //     this.add(this.buildings[i]);
                // }
            }
        }
    </script>
</body>

</html>